import socket
import threading
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from collections import deque

HOST = '10.42.0.1'  # Escucha en todas las interfaces
TCP_PORT = 5000   # Puerto definido para TCP 
UDP_PORT = 5001   # Puerto definido para UDP 
SWITCH_LIMIT = 50 # Cantidad de mensajes TCP antes de pedir el cambio a UDP [cite: 5]

data_values = deque([0]*100, maxlen=100)
lock = threading.Lock()

message_count = 0
switch_sent = False

def procesar_datos(data_str):
    try:
        val = float(data_str)
        return val
    except ValueError:
        ascii_vals = [ord(c) for c in data_str]
        avg_ascii = sum(ascii_vals) / len(ascii_vals) if ascii_vals else 0
        return avg_ascii

def tcp_server():
    global message_count, switch_sent
    
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, TCP_PORT))
        s.listen()
        print(f"[*] Servidor TCP escuchando en {HOST}:{TCP_PORT}")
        
        conn, addr = s.accept()
        with conn:
            print(f"[+] Conexión TCP establecida con {addr}") # [cite: 7]
            
            while True:
                try:
                    data = conn.recv(1024)
                    if not data:
                        break
                    
                    decoded_data = data.decode('utf-8', errors='ignore')
                    length = len(data)
                    
                    print(f"[TCP] De: {addr} | Largo: {length} bytes | Msg: {decoded_data[:20]}...")
                    
                    valor_grafico = procesar_datos(decoded_data)
                    with lock:
                        data_values.append(valor_grafico)
                    
                    message_count += 1
                    
                    if message_count >= SWITCH_LIMIT and not switch_sent:
                        print("--- ENVIANDO ORDEN DE CAMBIO A UDP ---")
                        conn.sendall(b"SWITCH_TO_UDP")
                        switch_sent = True
                except Exception as e:
                    print(f"Error TCP: {e}")
                    break

def udp_server():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
        s.bind((HOST, UDP_PORT))
        print(f"[*] Servidor UDP escuchando en {HOST}:{UDP_PORT}")
        
        while True:
            try:
                data, addr = s.recvfrom(1024)
                decoded_data = data.decode('utf-8', errors='ignore')
                length = len(data)
                
                print(f"[UDP] De: {addr} | Largo: {length} bytes | Msg: {decoded_data[:20]}...")
                
                valor_grafico = procesar_datos(decoded_data)
                with lock:
                    data_values.append(valor_grafico)
                    
            except Exception as e:
                print(f"Error UDP: {e}")

def animate(i):
    with lock:
        data_list = list(data_values)
    
    ax.clear()
    ax.plot(data_list, label='Datos Recibidos (Numérico o ASCII)')
    ax.set_title(f'Evolución de Datos (TCP -> UDP) ')
    ax.set_ylabel('Valor (Numérico / ASCII)')
    ax.legend(loc='upper left')
    ax.grid(True)

if __name__ == "__main__":
    thread_tcp = threading.Thread(target=tcp_server, daemon=True)
    thread_udp = threading.Thread(target=udp_server, daemon=True)
    
    thread_tcp.start()
    thread_udp.start()
    
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    
    ani = animation.FuncAnimation(fig, animate, interval=200)
    
    print("--- Sistema Iniciado. Esperando al ESP32... ---")
    plt.show()
